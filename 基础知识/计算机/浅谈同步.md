
linux， C， C++ 全方位谈一下同步机制

# 1.多进程同步
## XSI IPC：信号量，消息队列，共享内存
### 信号量
计数器，用于同步多个进程。
### 消息队列
消息队列与命名管道类似，但少了打开和关闭管道方面的复杂性。使用消息队列并未解决我们在使用命名管道时遇到的一些问题，如管道满时的阻塞问题。消息队列提供了一种在两个不相关进程间传递数据的简单有效的方法。与命名管道相比：消息队列的优势在于，它独立于发送和接收进程而存在，这消除了在同步命名管道的打开和关闭时可能产生的一些困难。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。而且，每个数据块被认为含有一个类型，接收进程可以独立地接收含有不同类型值的数据块。
### 共享内存
shm，/dev/zero

## POSIX 信号量
sem,分为命名信号量和无命名信号量
sem_open, sem_unlink, sem_trywait, sem_wait, sem_timedwait, sem_post, sem_init, sem_destroy, sem_destroy
二进制信号量可以当作互斥锁使用
- 1.添加读的计数需要上锁
- 2.写操作时候需要上锁
- 3.在读的时候需要锁写操作
- 4.给读操作加上一个写抢占的锁（具体对应为读计数操作加锁）
- 5.添加一个写操作的计数，为了可以进行抢占的时候给读操作上锁
- 6.为什么不能将这个抢占锁添加为整个的读操作里面而只是添加在读操作的计数增加？ 
    答：如果添加在了整个读操作里面，那么整个读就都变成了单线程的操作了，我们目的只是为了禁止读操作的运行。
    
## 网络IPC：socket
## 管道
PIPE，一般用于父进程和子进程通信。匿名管道一般为半双工。在相关的进程间使用，且两个进程需要有共同的父进程。
## 有名管道
FIFO，不相关的进程也能交换资源。管道通信方式的中间介质是文件，通常称这种文件为管道文件。两个进程利用管道文件进行通信时，一个进程为写进程，另一个进程为读进程。写进程通过写端（发送端）往管道文件中写入信息；读进程通过读端（接收端）从管道文件中读取信息。两个进程协调不断地进行写、读，便会构成双方通过管道传递信息的流水线。

# 2.多线程同步
线程需要同步的原因是因为存在A线程读，B线程修改同一内存。
## 互斥量
本质上是一把锁，mutex。如果拿不到锁，则会进行**休眠**阻塞，直到能够拿到锁。
## 自旋锁
和mutex有点类似，但是不是休眠，而是忙等。好处是不会无效调度；坏处是浪费CPU资源。
常用场景是，持锁时间短的场景。
## 屏障
barrier： 多个线程并行工作的同步机制，例如pthread_join函数就是一种屏障。

# 3.内核同步
